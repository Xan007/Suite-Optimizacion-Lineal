<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suite Optimizaci√≥n Lineal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f7fa;
            color: #1a1a1a;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2.5rem;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1rem;
            color: #666;
            font-weight: 400;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 900px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e8ecf1;
        }

        .card h2 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #1a1a1a;
        }

        .form-group {
            margin-bottom: 1.2rem;
        }

        label {
            display: block;
            font-size: 0.95rem;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 0.6rem;
        }

        textarea,
        input[type="file"],
        input[type="text"] {
            width: 100%;
            padding: 0.9rem;
            border: 2px solid #e0e4e8;
            border-radius: 10px;
            font-family: inherit;
            font-size: 0.95rem;
            color: #1a1a1a;
            transition: border-color 0.2s;
        }

        textarea:focus,
        input:focus {
            outline: none;
            border-color: #0066cc;
            background-color: #f8fbff;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 0.9rem 1.8rem;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #0052a3;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-group {
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
            margin: 1rem 0;
        }

        .method-btn {
            background: white;
            color: #0066cc;
            border: 2px solid #0066cc;
            padding: 0.7rem 1.4rem;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .method-btn:hover {
            background: #f0f4ff;
        }

        .method-btn.active {
            background: #0066cc;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1a1a1a;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        .result-panel {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e8ecf1;
        }

        .model-display {
            background: #f8fbff;
            border-left: 4px solid #0066cc;
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
        }

        .model-display .title {
            font-size: 1rem;
            font-weight: 700;
            color: #0066cc;
            margin-bottom: 0.8rem;
        }

        .objective-line {
            font-size: 0.95rem;
            margin: 0.5rem 0;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .constraints-list {
            margin-top: 1rem;
        }

        .constraint-item {
            font-size: 0.9rem;
            padding: 0.5rem 0;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .solver-result {
            margin-top: 1.5rem;
        }

        .result-card {
            background: #f0f4ff;
            border: 1px solid #d0deff;
            border-radius: 10px;
            padding: 1.2rem;
            margin-bottom: 1rem;
        }

        .result-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #0066cc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.4rem;
        }

        .result-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .step-iteration {
            background: white;
            border: 1px solid #e0e4e8;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.8rem;
        }

        .step-header {
            font-weight: 700;
            color: #0066cc;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .step-detail {
            font-size: 0.85rem;
            color: #666;
            margin: 0.3rem 0;
            font-family: 'Courier New', monospace;
        }

        .variables-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .var-item {
            background: #f8fbff;
            border-left: 3px solid #0066cc;
            padding: 1rem;
            border-radius: 8px;
        }

        .var-name {
            font-weight: 600;
            color: #0066cc;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }

        .var-value {
            font-size: 1.3rem;
            font-weight: 700;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 1rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            padding: 0.8rem;
            text-align: left;
            font-size: 0.9rem;
        }

        th {
            background: #f0f4ff;
            color: #0066cc;
            font-weight: 700;
            border-bottom: 2px solid #d0deff;
        }

        td {
            border-bottom: 1px solid #e0e4e8;
            color: #1a1a1a;
        }

        tr:hover {
            background: #f8fbff;
        }

        .method-explanation {
            background: #fff8f0;
            border-left: 4px solid #ff9500;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #333;
            line-height: 1.6;
            margin: 1rem 0;
            white-space: pre-wrap;
        }

        .sensitivity-section {
            background: #f0fff4;
            border-left: 4px solid #00aa44;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .sensitivity-title {
            font-weight: 700;
            color: #00aa44;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        .message {
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            font-size: 0.95rem;
        }

        .message.error {
            background: #fff0f0;
            color: #c00;
            border: 1px solid #ffcccc;
        }

        .message.success {
            background: #f0fff4;
            color: #00aa44;
            border: 1px solid #ccffdd;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid #0066cc;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
            vertical-align: middle;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .no-applicable {
            background: #fff0f0;
            border-left: 4px solid #cc0000;
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .no-applicable-title {
            font-weight: 700;
            color: #cc0000;
            margin-bottom: 0.5rem;
        }

        .no-applicable-item {
            color: #666;
            margin: 0.4rem 0;
            padding-left: 1rem;
        }
    </style>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'] }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
    <!-- Chart.js para gr√°ficos (reemplaza Plotly) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>

<body>
    <header>
        <h1>Suite Optimizaci√≥n Lineal</h1>
        <p class="subtitle">An√°lisis y resoluci√≥n de problemas de programaci√≥n lineal</p>
    </header>

    <div class="container">
        <div class="two-column">
            <!-- INPUT SECTION -->
            <div class="card">
                <h2>üìù Ingresar Problema</h2>

                <div class="form-group">
                    <label>Descripci√≥n (Texto)</label>
                    <textarea id="problem-text"
                        placeholder="Ejemplo: Maximizar 3x + 2y sujeto a: x + y ‚â§ 4; x ‚â§ 3; x,y ‚â• 0"></textarea>
                    <button onclick="analyzeText()" style="margin-top: 0.8rem; width: 100%;">Analizar Problema</button>
                </div>

                <div style="text-align: center; color: #ccc; margin: 1.5rem 0;">o</div>

                <div class="form-group">
                    <label>An√°lisis desde Imagen</label>
                    <input type="file" id="image-file" accept="image/*">
                    <textarea id="image-description" placeholder="Descripci√≥n adicional (opcional)"
                        style="margin-top: 0.8rem; height: 80px;"></textarea>
                    <button onclick="analyzeImage()" style="margin-top: 0.8rem; width: 100%;">Analizar Imagen</button>
                </div>

                <div id="message" style="margin-top: 1rem;"></div>
            </div>

            <!-- RESULT SECTION -->
            <div class="result-panel">
                <h2>üìä Modelo Can√≥nico</h2>
                <div id="model-display">
                    <p style="color: #999; font-style: italic;">Aqu√≠ aparecer√° el modelo despu√©s del an√°lisis...</p>
                </div>

                <div class="section-title">M√©todos Disponibles</div>
                <div id="methods-container">
                    <p style="color: #999; font-size: 0.9rem;">Selecciona un m√©todo despu√©s de analizar el problema</p>
                </div>

                <div id="not-applicable-methods" style="margin-top: 1rem;"></div>

                <button id="solve-btn" onclick="solveProblem()" style="width: 100%; margin-top: 1.5rem; display: none;">
                    ‚ñ∂ Ejecutar M√©todo Seleccionado
                </button>
            </div>
        </div>

        <!-- SOLUTION SECTION -->
        <div id="solution-section" style="display: none;">
            <div class="result-panel">
                <h2>üéØ Soluci√≥n</h2>
                <div id="solution-content"></div>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // CONFIGURACI√ìN GLOBAL
        // ====================================================================
        const apiBase = '/api/v1';
        let lastAnalysis = null;
        let selectedMethod = null;

        // ====================================================================
        // AN√ÅLISIS: Entrada de datos (texto e imagen)
        // ====================================================================
        async function analyzeText() {
            const text = document.getElementById('problem-text').value;
            if (!text.trim()) {
                showMessage('Por favor ingresa una descripci√≥n del problema', 'error');
                return;
            }
            await analyze({ problem: text });
        }

        async function analyzeImage() {
            const file = document.getElementById('image-file').files[0];
            if (!file) {
                showMessage('Por favor selecciona una imagen', 'error');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            const desc = document.getElementById('image-description').value;
            if (desc) formData.append('problem_description', desc);

            try {
                showMessage('Analizando imagen...', 'processing');
                const resp = await fetch(`${apiBase}/analyze/analyze-image`, { method: 'POST', body: formData });
                if (!resp.ok) {
                    const err = await resp.json();
                    showMessage(err.detail || 'Error al analizar imagen', 'error');
                    return;
                }
                const json = await resp.json();
                handleAnalysisResponse(json);
            } catch (e) {
                showMessage(`Error: ${e.message}`, 'error');
            }
        }

        async function analyze(payload) {
            try {
                showMessage('Analizando problema...', 'processing');
                const resp = await fetch(`${apiBase}/analyze/`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!resp.ok) {
                    const err = await resp.json();
                    showMessage(err.detail || 'Error en an√°lisis', 'error');
                    return;
                }
                const json = await resp.json();
                handleAnalysisResponse(json);
            } catch (e) {
                showMessage(`Error: ${e.message}`, 'error');
            }
        }

        // ====================================================================
        // AN√ÅLISIS: Procesamiento de respuesta
        // ====================================================================
        function handleAnalysisResponse(json) {
            lastAnalysis = json;
            showMessage('‚úì An√°lisis completado', 'success');

            // Mostrar modelo
            const model = json.mathematical_model || (json.result && json.result.mathematical_model);
            if (model) {
                displayModel(model);
            }

            // Mostrar m√©todos
            const suggested = json.suggested_methods || (json.result && json.result.suggested_methods) || [];
            const notApplicable = json.methods_not_applicable || (json.result && json.result.methods_not_applicable) || {};

            const methodsContainer = document.getElementById('methods-container');
            methodsContainer.innerHTML = '';

            if (suggested.length > 0) {
                const btnGroup = document.createElement('div');
                btnGroup.className = 'btn-group';
                suggested.forEach(m => {
                    const btn = document.createElement('button');
                    btn.className = 'method-btn';
                    btn.textContent = m.charAt(0).toUpperCase() + m.slice(1);
                    btn.onclick = () => selectMethod(m, btn);
                    btnGroup.appendChild(btn);
                });
                methodsContainer.appendChild(btnGroup);
            }

            if (Object.keys(notApplicable).length > 0) {
                const notAppDiv = document.createElement('div');
                notAppDiv.className = 'no-applicable';
                const title = document.createElement('div');
                title.className = 'no-applicable-title';
                title.textContent = '‚úó M√©todos no aplicables:';
                notAppDiv.appendChild(title);
                for (const [method, reason] of Object.entries(notApplicable)) {
                    const item = document.createElement('div');
                    item.className = 'no-applicable-item';
                    item.textContent = `${method}: ${reason}`;
                    notAppDiv.appendChild(item);
                }
                document.getElementById('not-applicable-methods').innerHTML = '';
                document.getElementById('not-applicable-methods').appendChild(notAppDiv);
            }

            document.getElementById('solve-btn').style.display = 'none';
        }

        // ====================================================================
        // M√âTODO: Selecci√≥n y ejecuci√≥n
        // ====================================================================
        function selectMethod(method, btnElement) {
            selectedMethod = method;
            document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
            btnElement.classList.add('active');
            document.getElementById('solve-btn').style.display = 'block';
        }

        // ====================================================================
        // VISUALIZACI√ìN: Modelo matem√°tico
        // ====================================================================
        function displayModel(model) {
            const div = document.createElement('div');
            div.className = 'model-display';

            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = (model.objective === 'min' ? 'üìâ Minimizar' : 'üìà Maximizar');
            div.appendChild(title);

            // Mostrar funci√≥n objetivo en LaTeX si est√° disponible
            const objLine = document.createElement('div');
            objLine.className = 'objective-line';
            const objText = model.objective_function_latex || model.objective_function;
            objLine.innerHTML = `$$${objText}$$`;
            div.appendChild(objLine);

            if (model.constraints && model.constraints.length > 0) {
                const consTitle = document.createElement('div');
                consTitle.style.fontWeight = '600';
                consTitle.style.color = '#1a1a1a';
                consTitle.style.marginTop = '1rem';
                consTitle.textContent = 'Sujeto a:';
                div.appendChild(consTitle);

                const consList = document.createElement('div');
                consList.className = 'constraints-list';
                if (model.constraints_latex && model.constraints_latex.length > 0) {
                    model.constraints_latex.forEach((c, idx) => {
                        const item = document.createElement('div');
                        item.className = 'constraint-item';
                        item.innerHTML = `$$${c}$$`;
                        consList.appendChild(item);
                    });
                } else {
                    model.constraints.forEach(c => {
                        const item = document.createElement('div');
                        item.className = 'constraint-item';
                        item.innerHTML = `$$${c}$$`;
                        consList.appendChild(item);
                    });
                }
                div.appendChild(consList);
            }

            // No-negatividad en LaTeX
            if (model.non_negativity_latex && model.non_negativity_latex.length > 0) {
                const nonnegTitle = document.createElement('div');
                nonnegTitle.style.fontWeight = '600';
                nonnegTitle.style.color = '#1a1a1a';
                nonnegTitle.style.marginTop = '0.8rem';
                nonnegTitle.style.fontSize = '0.9rem';
                nonnegTitle.textContent = 'No-negatividad:';
                div.appendChild(nonnegTitle);

                const nonnegList = document.createElement('div');
                nonnegList.className = 'constraints-list';
                model.non_negativity_latex.forEach(c => {
                    const item = document.createElement('div');
                    item.className = 'constraint-item';
                    item.style.fontSize = '0.85rem';
                    item.innerHTML = `$$${c}$$`;
                    nonnegList.appendChild(item);
                });
                div.appendChild(nonnegList);
            }

            document.getElementById('model-display').innerHTML = '';
            document.getElementById('model-display').appendChild(div);

            // Renderizar MathJax despu√©s de insertar el contenido
            if (window.MathJax) {
                MathJax.contentDocument = document;
                MathJax.typesetPromise([div]).catch(err => console.error('MathJax error:', err));
            }
        }

        async function solveProblem() {
            if (!lastAnalysis) {
                showMessage('Por favor analiza un problema primero', 'error');
                return;
            }
            if (!selectedMethod) {
                showMessage('Por favor selecciona un m√©todo', 'error');
                return;
            }

            const model = lastAnalysis.mathematical_model || (lastAnalysis.result && lastAnalysis.result.mathematical_model);
            if (!model) {
                showMessage('Error: no se encontr√≥ el modelo', 'error');
                return;
            }

            try {
                showMessage('Resolviendo...', 'processing');
                const payload = { model, method: selectedMethod };
                const resp = await fetch(`${apiBase}/analyze/solve`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    showMessage(err.detail || 'Error al resolver', 'error');
                    return;
                }

                const json = await resp.json();
                if (json.result) {
                    displaySolution(json.result);
                    showMessage('‚úì Problema resuelto exitosamente', 'success');
                }
            } catch (e) {
                showMessage(`Error: ${e.message}`, 'error');
            }
        }

        // ====================================================================
        // SOLUCI√ìN: Visualizaci√≥n de resultados
        // ====================================================================
        function displaySolution(result) {
            console.log('displaySolution called with result:', result);
            document.getElementById('solution-section').style.display = 'block';
            const content = document.getElementById('solution-content');
            content.innerHTML = '';

            // Limpiar gr√°ficas previas de Plotly
            const existingPlot = document.getElementById('graphical-plot');
            if (existingPlot) existingPlot.remove();

            // M√©todo
            const methodDiv = document.createElement('div');
            methodDiv.style.marginBottom = '1.5rem';
            const methodLabel = document.createElement('div');
            methodLabel.style.fontSize = '0.9rem';
            methodLabel.style.color = '#0066cc';
            methodLabel.style.fontWeight = '600';
            methodLabel.style.marginBottom = '0.3rem';
            methodLabel.textContent = 'M√âTODO USADO';
            methodDiv.appendChild(methodLabel);
            const methodName = document.createElement('div');
            methodName.style.fontSize = '1.4rem';
            methodName.style.fontWeight = '700';
            methodName.style.color = '#1a1a1a';
            methodName.textContent = result.method ? result.method.toUpperCase() : 'RESULTADO';
            methodDiv.appendChild(methodName);
            content.appendChild(methodDiv);

            // Objetivo
            if (result.objective_value !== undefined) {
                const objDiv = document.createElement('div');
                objDiv.className = 'result-card';
                const label = document.createElement('div');
                label.className = 'result-label';
                label.textContent = 'Valor √ìptimo';
                objDiv.appendChild(label);
                const val = document.createElement('div');
                val.className = 'result-value';
                val.textContent = formatNumber(result.objective_value, 6);
                objDiv.appendChild(val);
                content.appendChild(objDiv);
                console.log('Rendered objective value:', result.objective_value);
            } else {
                console.warn('No objective_value in result');
            }

            // ===== MOSTRAR ECUACIONES LaTeX CON VARIABLES DE HOLGURA (SOLO PARA SIMPLEX) =====
            if (result.method === 'simplex' && result.equations_latex && result.equations_latex.trim().length > 0) {
                const eqTitle = document.createElement('div');
                eqTitle.className = 'section-title';
                eqTitle.textContent = 'Ecuaciones con Variables de Holgura';
                content.appendChild(eqTitle);

                const eqDiv = document.createElement('div');
                eqDiv.style.background = '#f8fbff';
                eqDiv.style.border = '2px solid #0066cc';
                eqDiv.style.borderRadius = '10px';
                eqDiv.style.padding = '1.5rem';
                eqDiv.style.marginBottom = '1.5rem';
                eqDiv.style.lineHeight = '2.2';

                eqDiv.innerHTML = result.equations_latex;
                content.appendChild(eqDiv);

                // Renderizar MathJax para las ecuaciones
                if (window.MathJax) {
                    MathJax.contentDocument = document;
                    MathJax.typesetPromise([eqDiv]).catch(err => console.warn('MathJax error:', err));
                }
            }

            // Variables
            if (result.variables && Object.keys(result.variables).length > 0) {
                const varTitle = document.createElement('div');
                varTitle.className = 'section-title';
                varTitle.textContent = 'Valores de Variables';
                content.appendChild(varTitle);

                const varGrid = document.createElement('div');
                varGrid.className = 'variables-grid';
                for (const [name, value] of Object.entries(result.variables)) {
                    const item = document.createElement('div');
                    item.className = 'var-item';
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'var-name';
                    nameDiv.textContent = name;
                    item.appendChild(nameDiv);
                    const valDiv = document.createElement('div');
                    valDiv.className = 'var-value';
                    valDiv.textContent = formatNumber(Number(value), 6);
                    item.appendChild(valDiv);
                    varGrid.appendChild(item);
                }
                content.appendChild(varGrid);
            } else {
                console.warn('No variables in result');
            }

            // Explicaci√≥n
            if (result.explanation) {
                const exTitle = document.createElement('div');
                exTitle.className = 'section-title';
                exTitle.textContent = 'Procedimiento Aplicado';
                content.appendChild(exTitle);

                const exDiv = document.createElement('div');
                exDiv.className = 'method-explanation';
                exDiv.textContent = result.explanation;
                content.appendChild(exDiv);
            }

            // Pasos - renderizado diferente seg√∫n el m√©todo
            if (result.steps && result.steps.length > 0) {
                const stepsTitle = document.createElement('div');
                stepsTitle.className = 'section-title';
                stepsTitle.textContent = `Evaluaci√≥n de V√©rtices (${result.steps.length})`;
                content.appendChild(stepsTitle);

                const stepsContainer = document.createElement('div');

                // Para m√©todo gr√°fico, mostrar de forma simplificada
                if (result.method === 'graphical') {
                    result.steps.forEach(step => {
                        const stepCard = document.createElement('div');
                        stepCard.className = 'step-iteration';
                        stepCard.style.marginBottom = '1rem';
                        stepCard.style.padding = '1rem';
                        stepCard.style.border = '1px solid #ddd';
                        stepCard.style.borderRadius = '8px';
                        stepCard.style.backgroundColor = step.is_optimal ? '#f0fff0' : '#ffffff';

                        const header = document.createElement('div');
                        header.style.fontWeight = '600';
                        header.style.marginBottom = '0.5rem';
                        header.style.color = step.is_optimal ? '#008000' : '#0066cc';
                        header.innerHTML = `
                            V√©rtice ${step.iteration}: (${step.point[0].toFixed(4)}, ${step.point[1].toFixed(4)})
                            ${step.is_optimal ? '<strong style="color: #ff6b35;"> ‚≠ê √ìPTIMO</strong>' : ''}
                        `;
                        stepCard.appendChild(header);

                        const value = document.createElement('div');
                        value.style.fontSize = '0.95rem';
                        value.textContent = `Valor Objetivo: ${step.objective_value.toFixed(6)}`;
                        stepCard.appendChild(value);

                        stepsContainer.appendChild(stepCard);
                    });
                } else {
                    // Para Simplex y otros m√©todos, mostrar tablas detalladas
                    result.steps.forEach(step => {
                        const stepCard = document.createElement('div');
                        stepCard.className = 'step-iteration';
                        stepCard.style.marginBottom = '2rem';
                        stepCard.style.padding = '1.5rem';
                        stepCard.style.border = '1px solid #ddd';
                        stepCard.style.borderRadius = '8px';

                        // Encabezado de iteraci√≥n
                        const header = document.createElement('div');
                        header.className = 'step-header';
                        header.style.fontSize = '1.1rem';
                        header.style.fontWeight = '700';
                        header.style.marginBottom = '1rem';
                        header.style.color = '#0066cc';
                        header.textContent = `Iteraci√≥n ${step.iteration}`;
                        stepCard.appendChild(header);

                        // Info de pivote
                        if (step.entering_variable && step.leaving_variable) {
                            const pivotInfo = document.createElement('div');
                            pivotInfo.style.marginBottom = '1rem';
                            pivotInfo.style.padding = '0.8rem';
                            pivotInfo.style.backgroundColor = '#f0f4ff';
                            pivotInfo.style.borderRadius = '6px';
                            pivotInfo.innerHTML = `
                                <div style="font-weight: 600; margin-bottom: 0.3rem;">Operaci√≥n Pivote</div>
                                <div>Variable Entrante: <strong>${step.entering_variable}</strong></div>
                                <div>Variable Saliente: <strong>${step.leaving_variable}</strong></div>
                                <div>Elemento Pivote: <strong>${formatNumber(step.pivot_element, 4)}</strong></div>
                                <div>Fila Pivote: ${step.leaving_row}, Columna Pivote: ${step.entering_col}</div>
                            `;
                            stepCard.appendChild(pivotInfo);
                        }

                        // Tabla ANTES
                        if (step.tableau_before) {
                            const beforeTitle = document.createElement('div');
                            beforeTitle.style.fontWeight = '600';
                            beforeTitle.style.marginTop = '1rem';
                            beforeTitle.style.marginBottom = '0.5rem';
                            beforeTitle.textContent = 'Tabla Antes del Pivote:';
                            stepCard.appendChild(beforeTitle);

                            const beforeTable = document.createElement('table');
                            beforeTable.style.width = '100%';
                            beforeTable.style.borderCollapse = 'collapse';
                            beforeTable.style.fontSize = '0.85rem';
                            beforeTable.style.marginBottom = '1rem';
                            beforeTable.style.overflowX = 'auto';
                            beforeTable.style.display = 'block';

                            // Headers
                            const thead = document.createElement('thead');
                            const headerRow = document.createElement('tr');
                            headerRow.style.backgroundColor = '#f5f5f5';

                            const baseHeader = document.createElement('th');
                            baseHeader.textContent = 'Base';
                            baseHeader.style.padding = '0.4rem';
                            baseHeader.style.border = '1px solid #ddd';
                            baseHeader.style.textAlign = 'left';
                            headerRow.appendChild(baseHeader);

                            if (step.var_names) {
                                step.var_names.forEach(v => {
                                    const th = document.createElement('th');
                                    th.textContent = v;
                                    th.style.padding = '0.4rem';
                                    th.style.border = '1px solid #ddd';
                                    th.style.textAlign = 'center';
                                    th.style.fontWeight = '600';
                                    headerRow.appendChild(th);
                                });
                            }

                            // Slack variables headers
                            for (let i = 0; i < step.tableau_before[0].length - step.var_names.length - 1; i++) {
                                const th = document.createElement('th');
                                th.textContent = `s${i + 1}`;
                                th.style.padding = '0.4rem';
                                th.style.border = '1px solid #ddd';
                                th.style.textAlign = 'center';
                                th.style.fontWeight = '600';
                                headerRow.appendChild(th);
                            }

                            const rhsHeader = document.createElement('th');
                            rhsHeader.textContent = 'RHS';
                            rhsHeader.style.padding = '0.4rem';
                            rhsHeader.style.border = '1px solid #ddd';
                            rhsHeader.style.textAlign = 'center';
                            rhsHeader.style.fontWeight = '600';
                            headerRow.appendChild(rhsHeader);

                            thead.appendChild(headerRow);
                            beforeTable.appendChild(thead);

                            // Body
                            const tbody = document.createElement('tbody');
                            step.tableau_before.forEach((row, rowIdx) => {
                                const tr = document.createElement('tr');
                                tr.style.backgroundColor = rowIdx === step.leaving_row ? '#ffe0e0' : '#ffffff';

                                const baseCell = document.createElement('td');
                                baseCell.textContent = step.basis_before[rowIdx];
                                baseCell.style.padding = '0.4rem';
                                baseCell.style.border = '1px solid #ddd';
                                baseCell.style.fontWeight = '600';
                                tr.appendChild(baseCell);

                                row.forEach((val, colIdx) => {
                                    const td = document.createElement('td');
                                    td.textContent = formatNumber(val, 4);
                                    td.style.padding = '0.4rem';
                                    td.style.border = '1px solid #ddd';
                                    td.style.textAlign = 'center';
                                    if (rowIdx === step.leaving_row && colIdx === step.entering_col) {
                                        td.style.backgroundColor = '#ffcc00';
                                        td.style.fontWeight = '700';
                                    }
                                    tr.appendChild(td);
                                });
                                tbody.appendChild(tr);
                            });

                            // Fila de objetivo
                            const objRow = document.createElement('tr');
                            objRow.style.backgroundColor = '#e0e0ff';
                            const objLabel = document.createElement('td');
                            objLabel.textContent = 'Z';
                            objLabel.style.padding = '0.4rem';
                            objLabel.style.border = '1px solid #ddd';
                            objLabel.style.fontWeight = '600';
                            objRow.appendChild(objLabel);
                            step.obj_row_before.forEach((val, idx) => {
                                const td = document.createElement('td');
                                td.textContent = formatNumber(val, 4);
                                td.style.padding = '0.4rem';
                                td.style.border = '1px solid #ddd';
                                td.style.textAlign = 'center';
                                if (idx === step.entering_col) {
                                    td.style.backgroundColor = '#ffff99';
                                    td.style.fontWeight = '700';
                                }
                                objRow.appendChild(td);
                            });
                            tbody.appendChild(objRow);

                            beforeTable.appendChild(tbody);
                            stepCard.appendChild(beforeTable);
                        }

                        // Tabla DESPU√âS
                        if (step.tableau_after) {
                            const afterTitle = document.createElement('div');
                            afterTitle.style.fontWeight = '600';
                            afterTitle.style.marginTop = '1rem';
                            afterTitle.style.marginBottom = '0.5rem';
                            afterTitle.textContent = 'Tabla Despu√©s del Pivote:';
                            stepCard.appendChild(afterTitle);

                            const afterTable = document.createElement('table');
                            afterTable.style.width = '100%';
                            afterTable.style.borderCollapse = 'collapse';
                            afterTable.style.fontSize = '0.85rem';
                            afterTable.style.display = 'block';
                            afterTable.style.overflowX = 'auto';

                            // Headers
                            const thead = document.createElement('thead');
                            const headerRow = document.createElement('tr');
                            headerRow.style.backgroundColor = '#f5f5f5';

                            const baseHeader = document.createElement('th');
                            baseHeader.textContent = 'Base';
                            baseHeader.style.padding = '0.4rem';
                            baseHeader.style.border = '1px solid #ddd';
                            baseHeader.style.textAlign = 'left';
                            headerRow.appendChild(baseHeader);

                            if (step.var_names) {
                                step.var_names.forEach(v => {
                                    const th = document.createElement('th');
                                    th.textContent = v;
                                    th.style.padding = '0.4rem';
                                    th.style.border = '1px solid #ddd';
                                    th.style.textAlign = 'center';
                                    th.style.fontWeight = '600';
                                    headerRow.appendChild(th);
                                });
                            }

                            for (let i = 0; i < step.tableau_after[0].length - step.var_names.length - 1; i++) {
                                const th = document.createElement('th');
                                th.textContent = `s${i + 1}`;
                                th.style.padding = '0.4rem';
                                th.style.border = '1px solid #ddd';
                                th.style.textAlign = 'center';
                                th.style.fontWeight = '600';
                                headerRow.appendChild(th);
                            }

                            const rhsHeader = document.createElement('th');
                            rhsHeader.textContent = 'RHS';
                            rhsHeader.style.padding = '0.4rem';
                            rhsHeader.style.border = '1px solid #ddd';
                            rhsHeader.style.textAlign = 'center';
                            rhsHeader.style.fontWeight = '600';
                            headerRow.appendChild(rhsHeader);

                            thead.appendChild(headerRow);
                            afterTable.appendChild(thead);

                            // Body
                            const tbody = document.createElement('tbody');
                            step.tableau_after.forEach((row, rowIdx) => {
                                const tr = document.createElement('tr');
                                tr.style.backgroundColor = '#ffffff';

                                const baseCell = document.createElement('td');
                                baseCell.textContent = step.basis_after[rowIdx];
                                baseCell.style.padding = '0.4rem';
                                baseCell.style.border = '1px solid #ddd';
                                baseCell.style.fontWeight = '600';
                                tr.appendChild(baseCell);

                                row.forEach((val, colIdx) => {
                                    const td = document.createElement('td');
                                    td.textContent = formatNumber(val, 4);
                                    td.style.padding = '0.4rem';
                                    td.style.border = '1px solid #ddd';
                                    td.style.textAlign = 'center';
                                    tr.appendChild(td);
                                });
                                tbody.appendChild(tr);
                            });

                            // Fila de objetivo
                            const objRow = document.createElement('tr');
                            objRow.style.backgroundColor = '#e0e0ff';
                            const objLabel = document.createElement('td');
                            objLabel.textContent = 'Z';
                            objLabel.style.padding = '0.4rem';
                            objLabel.style.border = '1px solid #ddd';
                            objLabel.style.fontWeight = '600';
                            objRow.appendChild(objLabel);
                            step.obj_row_after.forEach((val, idx) => {
                                const td = document.createElement('td');
                                td.textContent = formatNumber(val, 4);
                                td.style.padding = '0.4rem';
                                td.style.border = '1px solid #ddd';
                                td.style.textAlign = 'center';
                                objRow.appendChild(td);
                            });
                            tbody.appendChild(objRow);

                            afterTable.appendChild(tbody);
                            stepCard.appendChild(afterTable);
                        }

                        stepsContainer.appendChild(stepCard);
                    });
                }

                content.appendChild(stepsContainer);
            }

            // Si es m√©todo gr√°fico, intentar dibujar la gr√°fica ANTES de la tabla
            if (result.method === 'graphical') {
                try {
                    const model = lastAnalysis?.mathematical_model || result.mathematical_model || null;
                    // Graficar cuando Chart.js est√© disponible
                    plotGraphicalSolution(result, model);
                } catch (e) {
                    console.warn('Error preparando gr√°fica:', e);
                }
            }

            // Puntos factibles (tabla de v√©rtices)
            if (result.feasible_points && result.feasible_points.length > 0) {
                const pTitle = document.createElement('div');
                pTitle.className = 'section-title';
                pTitle.textContent = `Evaluaci√≥n de V√©rtices (${result.feasible_points.length} v√©rtices)`;
                content.appendChild(pTitle);

                const wrapper = document.createElement('div');
                wrapper.className = 'table-wrapper';
                const table = document.createElement('table');

                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['V√©rtice', 'Coordenada X', 'Coordenada Y', 'Valor Objetivo', 'Estado'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                result.feasible_points.forEach((pt, idx) => {
                    const tr = document.createElement('tr');
                    const isOptimal = pt.is_optimal || (result.optimal_point &&
                        result.optimal_point[0] === pt.point[0] &&
                        result.optimal_point[1] === pt.point[1]);

                    if (isOptimal) {
                        tr.style.background = '#fff3e0';
                        tr.style.fontWeight = '600';
                        tr.style.borderLeft = '4px solid #ff9800';
                    }

                    // V√©rtice n√∫mero
                    const numCell = document.createElement('td');
                    numCell.textContent = `V${idx + 1}`;
                    tr.appendChild(numCell);

                    // Coordenada X
                    const xCell = document.createElement('td');
                    xCell.textContent = formatNumber(Number(pt.point[0]), 4);
                    tr.appendChild(xCell);

                    // Coordenada Y
                    const yCell = document.createElement('td');
                    yCell.textContent = formatNumber(Number(pt.point[1]), 4);
                    tr.appendChild(yCell);

                    // Valor Objetivo
                    const objCell = document.createElement('td');
                    objCell.textContent = formatNumber(Number(pt.objective), 6);
                    objCell.style.fontFamily = 'monospace';
                    tr.appendChild(objCell);

                    // Estado
                    const statusCell = document.createElement('td');
                    statusCell.textContent = isOptimal ? '‚òÖ √ìPTIMO' : 'Factible';
                    statusCell.style.color = isOptimal ? '#ff6b35' : '#666';
                    statusCell.style.fontWeight = isOptimal ? '700' : '400';
                    tr.appendChild(statusCell);

                    tbody.appendChild(tr);
                });
                table.appendChild(tbody);
                wrapper.appendChild(table);

                // Secci√≥n de Soluci√≥n √ìptima
                if (result.optimal_point) {
                    const optimalSection = document.createElement('div');
                    optimalSection.style.marginTop = '1.5rem';
                    optimalSection.style.padding = '1.2rem';
                    optimalSection.style.background = '#fff3e0';
                    optimalSection.style.border = '3px solid #ff9800';
                    optimalSection.style.borderRadius = '8px';
                    optimalSection.style.boxShadow = '0 2px 8px rgba(255, 152, 0, 0.15)';

                    const optimalTitle = document.createElement('div');
                    optimalTitle.style.fontWeight = '700';
                    optimalTitle.style.color = '#ff6b35';
                    optimalTitle.style.marginBottom = '0.8rem';
                    optimalTitle.style.fontSize = '1.2rem';
                    optimalTitle.textContent = '‚òÖ SOLUCI√ìN √ìPTIMA';
                    optimalSection.appendChild(optimalTitle);

                    // Valores de variables
                    const opPoint = Array.isArray(result.optimal_point) ? result.optimal_point : [result.optimal_point[0], result.optimal_point[1]];
                    const varNames = Object.keys(result.variables || {});
                    const varsList = document.createElement('div');
                    varsList.style.marginBottom = '0.8rem';
                    varNames.forEach((varName, idx) => {
                        const valLine = document.createElement('div');
                        valLine.style.marginBottom = '0.3rem';
                        valLine.style.fontSize = '0.95rem';
                        valLine.style.display = 'flex';
                        valLine.style.justifyContent = 'space-between';
                        valLine.style.paddingBottom = '0.3rem';
                        valLine.style.borderBottom = '1px solid rgba(255,152,0,0.1)';
                        valLine.innerHTML = `<strong>${varName}</strong> <span style="font-family: monospace; color: #0066cc;">${formatNumber(Number(opPoint[idx]), 4)}</span>`;
                        varsList.appendChild(valLine);
                    });
                    optimalSection.appendChild(varsList);

                    // Valor √≥ptimo de Z
                    const zLine = document.createElement('div');
                    zLine.style.marginTop = '0.8rem';
                    zLine.style.paddingTop = '0.8rem';
                    zLine.style.borderTop = '2px solid #ff9800';
                    zLine.style.fontWeight = '700';
                    zLine.style.fontSize = '1.15rem';
                    zLine.style.display = 'flex';
                    zLine.style.justifyContent = 'space-between';
                    zLine.innerHTML = `<span>Valor √≥ptimo:</span> <span style="color: #ff6b35; font-size: 1.3rem; font-family: monospace;">Z = ${formatNumber(Number(result.objective_value), 6)}</span>`;
                    optimalSection.appendChild(zLine);

                    wrapper.appendChild(optimalSection);
                }

                content.appendChild(wrapper);
            }

            // Sensibilidad
            if (result.sensitivity) {
                const senTitle = document.createElement('div');
                senTitle.className = 'section-title';
                senTitle.textContent = 'An√°lisis de Sensibilidad';
                content.appendChild(senTitle);

                const senDiv = document.createElement('div');
                senDiv.className = 'sensitivity-section';

                if (result.sensitivity.dual_prices && result.sensitivity.dual_prices.length > 0) {
                    const dp = document.createElement('div');
                    dp.className = 'sensitivity-title';
                    dp.textContent = 'Precios Sombra:';
                    senDiv.appendChild(dp);
                    const dpList = document.createElement('div');
                    dpList.style.marginBottom = '0.8rem';
                    dpList.textContent = result.sensitivity.dual_prices.map(v => formatNumber(v, 4)).join(', ');
                    senDiv.appendChild(dpList);
                }

                if (result.sensitivity.reduced_costs) {
                    const rc = document.createElement('div');
                    rc.className = 'sensitivity-title';
                    rc.textContent = 'Costos Reducidos:';
                    senDiv.appendChild(rc);
                    const rcList = document.createElement('div');
                    rcList.textContent = Object.entries(result.sensitivity.reduced_costs)
                        .map(([k, v]) => `${k}: ${formatNumber(Number(v), 4)}`)
                        .join(', ');
                    senDiv.appendChild(rcList);
                }

                if (result.sensitivity.note) {
                    const note = document.createElement('div');
                    note.style.marginTop = '0.8rem';
                    note.style.fontSize = '0.85rem';
                    note.style.color = '#666';
                    note.style.fontStyle = 'italic';
                    note.textContent = result.sensitivity.note;
                    senDiv.appendChild(note);
                }

                content.appendChild(senDiv);
            }

            // Si es m√©todo gr√°fico, intentar dibujar la gr√°fica
            if (result.method === 'graphical') {
                try {
                    const model = lastAnalysis?.mathematical_model || result.mathematical_model || null;
                    // Graficar cuando Chart.js est√© disponible
                    plotGraphicalSolution(result, model);
                } catch (e) {
                    console.warn('Error preparando gr√°fica:', e);
                }
            }
        }

        // ====================================================================
        // UTILIDADES: Mensajes y gr√°ficos
        // ====================================================================
        function showMessage(text, type) {
            const msgDiv = document.getElementById('message');
            msgDiv.className = `message ${type}`;
            if (type === 'processing') {
                msgDiv.innerHTML = `<span class="spinner"></span>${text}`;
            } else {
                msgDiv.textContent = text;
            }
        }

        // ====================================================================
        // Funci√≥n auxiliar para limpiar decimales
        // ====================================================================
        function formatNumber(num, decimals = 3) {
            if (typeof num !== 'number' || !isFinite(num)) return num;

            // Si todos los decimales son 0, mostrar como entero
            const rounded = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
            const str = rounded.toFixed(decimals);
            const decimal = Math.abs(rounded - Math.round(rounded));

            if (decimal < Math.pow(10, -decimals)) {
                return Math.round(rounded).toString();
            }

            // Remover ceros al final
            return str.replace(/\.?0+$/, '');
        }

        // ====================================================================
        function plotGraphicalSolution(result, model) {
            try {
                console.log('plotGraphicalSolution called with', result.feasible_points?.length, 'points');

                // Verificar que Chart.js est√© disponible
                if (!window.Chart) {
                    console.error('Chart.js not available');
                    return;
                }

                const existingContainer = document.getElementById('graphical-plot-container');
                if (existingContainer) existingContainer.remove();

                if (!result || !result.feasible_points || result.feasible_points.length === 0) {
                    console.warn('No feasible points to plot');
                    return;
                }

                // Normalizar puntos factibles a arrays [x,y]
                const pts = result.feasible_points.map(p =>
                    Array.isArray(p.point) ? p.point.map(Number) : [Number(p.point[0]), Number(p.point[1])]
                );

                // Calcular l√≠mites
                const xCoords = pts.map(p => p[0]);
                const yCoords = pts.map(p => p[1]);
                let xMin = Math.min(...xCoords);
                let xMax = Math.max(...xCoords);
                let yMin = Math.min(...yCoords);
                let yMax = Math.max(...yCoords);

                if (!isFinite(xMin) || !isFinite(xMax)) { xMin = -5; xMax = 5; }
                if (!isFinite(yMin) || !isFinite(yMax)) { yMin = -5; yMax = 5; }

                const xRange = xMax - xMin || 1;
                const yRange = yMax - yMin || 1;
                const xPad = xRange * 0.2;
                const yPad = yRange * 0.2;
                xMin -= xPad; xMax += xPad;
                yMin -= yPad; yMax += yPad;

                // Crear contenedor
                const containerDiv = document.createElement('div');
                containerDiv.id = 'graphical-plot-container';
                containerDiv.style.width = '100%';
                containerDiv.style.marginBottom = '1.5rem';
                containerDiv.style.marginTop = '1.5rem';
                containerDiv.style.border = '2px solid #ddd';
                containerDiv.style.borderRadius = '8px';
                containerDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                containerDiv.style.position = 'relative';
                containerDiv.style.height = '550px';

                const canvas = document.createElement('canvas');
                canvas.id = 'graphical-plot';
                containerDiv.appendChild(canvas);
                document.getElementById('solution-content').insertBefore(containerDiv, document.getElementById('solution-content').firstChild.nextSibling.nextSibling.nextSibling);

                // Datos para Chart.js
                const datasets = [];

                // Colores distintos para cada restricci√≥n
                const constraintColors = [
                    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                    '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
                    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'
                ];

                // Regi√≥n factible (pol√≠gono con sombreado azul) - PRIMERO en datasets para que quede atr√°s
                if (pts.length >= 3) {
                    const center = {
                        x: xCoords.reduce((a, b) => a + b, 0) / xCoords.length,
                        y: yCoords.reduce((a, b) => a + b, 0) / yCoords.length
                    };
                    const angles = pts.map((p, i) => ({
                        idx: i,
                        angle: Math.atan2(p[1] - center.y, p[0] - center.x)
                    })).sort((a, b) => a.angle - b.angle);

                    const polyPoints = angles.map(a => ({
                        x: pts[a.idx][0],
                        y: pts[a.idx][1]
                    }));
                    polyPoints.push(polyPoints[0]); // Cerrar pol√≠gono

                    // Crear dataset de pol√≠gono con muchos puntos intermedios para llenar bien
                    const filledPolyPoints = [];
                    for (let i = 0; i < polyPoints.length - 1; i++) {
                        filledPolyPoints.push(polyPoints[i]);
                        // Interpolar puntos intermedios
                        for (let t = 0.1; t < 1; t += 0.1) {
                            filledPolyPoints.push({
                                x: polyPoints[i].x + t * (polyPoints[i + 1].x - polyPoints[i].x),
                                y: polyPoints[i].y + t * (polyPoints[i + 1].y - polyPoints[i].y)
                            });
                        }
                    }
                    filledPolyPoints.push(polyPoints[polyPoints.length - 1]);

                    datasets.push({
                        label: '',  // Etiqueta vac√≠a para que no aparezca en hover
                        data: filledPolyPoints,
                        borderColor: 'rgba(100,150,200,0.9)',
                        backgroundColor: 'rgba(100,180,255,0.5)',
                        borderWidth: 2.5,
                        fill: true,
                        tension: 0.3,
                        showLine: true,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        borderDash: [],
                        segment: {
                            borderColor: ctx => 'rgba(100,150,200,0.9)',
                            borderDash: []
                        }
                    });
                }

                // L√≠neas de restricciones con ecuaciones reales
                if (result.constraints_info && result.constraints_info.length > 0) {
                    result.constraints_info.forEach((constraintData, idx) => {
                        try {
                            const a = Number(constraintData.a) || 0;
                            const b = Number(constraintData.b) || 0;
                            const rhs = Number(constraintData.rhs) || 0;

                            // Generar ecuaci√≥n en formato: "ax + by = c"
                            let equationStr = '';
                            if (Math.abs(a) > 1e-12) {
                                const aStr = a === 1 ? 'x' : (a === -1 ? '-x' : `${a.toFixed(2)}x`);
                                equationStr = aStr;
                            }
                            if (Math.abs(b) > 1e-12) {
                                const bStr = b > 0 ? '+' : '';
                                const bVal = b === 1 ? 'y' : (b === -1 ? '-y' : `${b.toFixed(2)}y`);
                                equationStr += (equationStr ? ' ' + bStr + ' ' + bVal : bVal);
                            }
                            equationStr += ` = ${rhs.toFixed(2)}`;

                            const lineColor = constraintColors[idx % constraintColors.length];
                            let linePoints = [];

                            if (Math.abs(b) > 1e-12) {
                                // L√≠nea: y = (rhs - a*x) / b
                                const steps = 200;
                                const step = (xMax - xMin) / steps;
                                for (let x = xMin; x <= xMax; x += step) {
                                    const y = (rhs - a * x) / b;
                                    if (y >= yMin - yPad && y <= yMax + yPad) {
                                        linePoints.push({ x: x.toFixed(2), y: y.toFixed(2) });
                                    }
                                }
                            } else if (Math.abs(a) > 1e-12) {
                                // L√≠nea vertical: x = rhs / a
                                const xv = rhs / a;
                                const steps = 200;
                                const step = (yMax - yMin) / steps;
                                for (let y = yMin; y <= yMax; y += step) {
                                    linePoints.push({ x: xv.toFixed(2), y: y.toFixed(2) });
                                }
                            }

                            if (linePoints.length > 0) {
                                datasets.push({
                                    label: equationStr,
                                    data: linePoints,
                                    borderColor: lineColor,
                                    borderWidth: 2.5,
                                    borderDash: [],
                                    pointRadius: 0,
                                    pointHoverRadius: 0,
                                    fill: false,
                                    tension: 0,
                                    showLine: true,
                                    tooltip: {
                                        callbacks: {
                                            label: () => equationStr
                                        }
                                    }
                                });
                            }
                        } catch (e) {
                            console.warn('Error plotting constraint:', e);
                        }
                    });
                }

                // V√©rtices factibles en negro
                datasets.push({
                    label: 'V√©rtices',
                    data: pts.map((p, i) => ({
                        x: p[0].toFixed(3),
                        y: p[1].toFixed(3),
                        vertexLabel: `V${i + 1}`
                    })),
                    borderColor: '#000000',
                    backgroundColor: '#000000',
                    borderWidth: 2,
                    pointRadius: 6,
                    pointHoverRadius: 8,
                    showLine: false,
                    fill: false,
                    tooltip: {
                        callbacks: {
                            label: (context) => context.raw.vertexLabel
                        }
                    }
                });

                // Punto √≥ptimo destacado
                if (result.optimal_point) {
                    const op = Array.isArray(result.optimal_point)
                        ? result.optimal_point.map(Number)
                        : [Number(result.optimal_point[0]), Number(result.optimal_point[1])];

                    datasets.push({
                        label: '√ìptimo',
                        data: [{
                            x: op[0].toFixed(3),
                            y: op[1].toFixed(3),
                            optimalLabel: '‚òÖ √ìptimo'
                        }],
                        borderColor: '#cc0000',
                        backgroundColor: '#ff6b35',
                        borderWidth: 3,
                        pointRadius: 12,
                        pointStyle: 'star',
                        pointHoverRadius: 15,
                        showLine: false,
                        fill: false,
                        tooltip: {
                            callbacks: {
                                label: (context) => context.raw.optimalLabel
                            }
                        }
                    });
                }

                // Opciones de Chart.js
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    boxWidth: 15,
                                    font: { size: 10 },
                                    padding: 10,
                                    filter: (item) => item.text !== '' // Ocultar etiqueta vac√≠a de regi√≥n factible
                                }
                            },
                            title: {
                                display: true,
                                text: 'Visualizaci√≥n del M√©todo Gr√°fico',
                                font: { size: 18, weight: 'bold' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        // Si el dataset tiene tooltip callbacks personalizados, usarlos
                                        if (context.dataset.tooltip?.callbacks?.label) {
                                            return context.dataset.tooltip.callbacks.label(context);
                                        }
                                        return context.dataset.label || '';
                                    }
                                },
                                backgroundColor: 'rgba(0,0,0,0.8)',
                                padding: 12,
                                titleFont: { size: 12 },
                                bodyFont: { size: 11 },
                                displayColors: false
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'x',
                                    font: { weight: 'bold', size: 14 }
                                },
                                min: xMin,
                                max: xMax,
                                grid: {
                                    display: true,
                                    drawBorder: true,
                                    color: 'rgba(200,200,200,0.3)'
                                },
                                ticks: {
                                    stepSize: xRange / 10
                                }
                            },
                            y: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'y',
                                    font: { weight: 'bold', size: 14 }
                                },
                                min: yMin,
                                max: yMax,
                                grid: {
                                    display: true,
                                    drawBorder: true,
                                    color: 'rgba(200,200,200,0.3)'
                                },
                                ticks: {
                                    stepSize: yRange / 10
                                }
                            }
                        }
                    }
                });

                console.log('Chart.js graph created successfully');

            } catch (error) {
                console.error('Error en plotGraphicalSolution:', error);
                const el = document.getElementById('graphical-plot-container');
                if (el) el.remove();
            }
        }
    </script>
</body>

</html>